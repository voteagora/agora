scalar BigInt
scalar Timestamp

type Query {
  delegate(addressOrEnsName: String!): Delegate!

  delegates(
    orderBy: DelegatesOrder! = weightedSort
    first: Int!
    after: String
    seed: String
  ): DelegatesConnection!

  votes(proposalId: ID!, first: Int!, after: String): VotesConnection!

  proposal(id: ID!): Proposal!
  proposals: [Proposal!]!

  metrics: Metrics!

  retroPGF: RetroPGF!
}

type Delegate {
  id: ID!
  address: Address!

  # Delegate where voting power has been delegated. Can be delegated to a
  # delegate with the same address as the account.
  delegatingTo: Delegate!

  statement: DelegateStatement

  amountOwned: VotingPower!
  tokensRepresented: VotingPower!
  tokensRepresentedSnapshot(proposalId: ID!): VotingPower!

  delegateMetrics: DelegateMetrics!
  proposed: [Proposal!]!

  votes: [Vote!]!
  snapshotVotes: [SnapshotVote!]!

  isCitizen: Boolean!
}

type Address {
  address: String!
  resolvedName: ResolvedName!
  isContract: Boolean!
}

type DelegateStatement {
  statement: String!
  summary: String
  topIssues: [TopIssue!]!
  mostValuableProposals: [Proposal!]!
  leastValuableProposals: [Proposal!]!
  twitter: String!
  discord: String!
  openToSponsoringProposals: Boolean
}

type ResolvedName {
  address: ID!
  name: String
}

type DelegateMetrics {
  totalVotes: Int!
  forVotes: Int!
  againstVotes: Int!
  abstainVotes: Int!
  ofLastTenProps: Int!
  ofTotalProps: Int!
  proposalsCreated: Int!
  tokenHoldersRepresentedCount: Int!
}

type Metrics {
  delegatedSupply: TokenAmount!
  totalSupply: TokenAmount!

  quorum: VotingPower!

  proposalThreshold: VotingPower!
}

type Vote {
  id: ID!
  reason: String!
  # todo: this should be an enum
  supportDetailed: Int!
  votes: VotingPower!

  proposal: Proposal!
  voter: Delegate!
  transaction: Transaction!

  options: [ApprovalVotingProposalOption!]
}

type Transaction {
  id: ID!
  hash: String!
  block: Block!
}

type Block {
  id: ID!
  number: BigInt!

  timestamp: Timestamp!
}

type TokenAmount {
  amount: BigInt!
  currency: String!
  decimals: Int!
}

type VotingPower {
  amount: TokenAmount!

  bpsOfQuorum: Int!
  bpsOfDelegatedSupply: Int!
  bpsOfTotal: Int!
}

type SnapshotVote {
  id: ID!
  choice: SnapshotVoteChoice!
  votingPower: Float!
  proposal: SnapshotProposal!
  createdAt: Timestamp!
  reason: String!
}

union SnapshotVoteChoice =
    SnapshotVoteChoiceApproval
  | SnapshotVoteChoiceRanked
  | SnapshotVoteChoiceSingle
  | SnapshotVoteChoiceQuadratic
  | SnapshotVoteChoiceWeighted

type SnapshotVoteChoiceApproval {
  approvedChoices: [Int!]!
}

type SnapshotVoteChoiceRanked {
  choices: [Int!]!
}

type SnapshotVoteChoiceSingle {
  selectedChoiceIdx: Int!
}

type SnapshotVoteChoiceQuadratic {
  weights: [WeightedSelectedChoice!]!
}

type SnapshotVoteChoiceWeighted {
  weights: [WeightedSelectedChoice!]!
}

type WeightedSelectedChoice {
  choiceIdx: Int!
  weight: Int!
}

type SnapshotProposal {
  id: ID!
  title: String!
  link: String!
  choices: [ProposalChoice!]!
}

type ProposalChoice {
  title: String!
  score: Float!
}

type TopIssue {
  type: String!
  value: String!
}

enum DelegatesOrder {
  mostVotingPower
  mostDelegates
  weightedRandom
}

type DelegatesConnection {
  pageInfo: PageInfo!
  edges: [DelegatesEdge!]!
}

type DelegatesEdge {
  node: Delegate!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type VotesConnection {
  pageInfo: PageInfo!
  edges: [VotesEdge!]!
}

type VotesEdge {
  node: Vote!
  cursor: String!
}

scalar Bytes

type Proposal {
  id: ID!
  number: BigInt!

  title: String!
  description: String!

  voteEndsAt: Timestamp!
  voteStartsAt: Timestamp!
  quorumVotes: TokenAmount!
  totalVotes: BigInt!

  proposalData: ProposalData!

  status: ProposalStatus!

  totalValue: BigInt!

  proposer: Delegate!
}

enum ProposalStatus {
  PENDING
  ACTIVE
  CANCELLED
  VETOED
  QUEUED
  SUCCEEDED
  EXECUTED
  DEFEATED
  EXPIRED
}

enum ProposalType {
  STANDARD
  APPROVAL_VOTING
}

union ProposalData = StandardProposalData | ApprovalVotingProposalData

type StandardProposalData {
  transactions: [ProposalTransaction!]

  forVotes: TokenAmount!
  againstVotes: TokenAmount!
  abstainVotes: TokenAmount!
}

type ApprovalVotingProposalData {
  settings: ApprovalVotingProposalSettings!
  options: [ApprovalVotingProposalOption!]!

  forVotes: TokenAmount!
  abstainVotes: TokenAmount!
}

type ProposalTransaction {
  target: Address!
  value: BigInt!
  signature: String!
  calldata: Bytes!

  functionName: String!
  functionArgs: [String]!
}

type ApprovalVotingProposalSettings {
  maxApprovals: Int!
  criteria: ApprovalVotingCriteria!
  budget: TokenAmount!
}

type ThresholdVotingCriteria {
  threshold: TokenAmount!
}

type TopChoicesVotingCriteria {
  topChoices: Int!
}

union ApprovalVotingCriteria =
    ThresholdVotingCriteria
  | TopChoicesVotingCriteria

type ApprovalVotingProposalOption {
  votes: TokenAmount!
  description: String!
  transactions: [ProposalTransaction!]

  budgetTokensSpent: TokenAmount!
}

type RetroPGF {
  badgeholders(orderBy: CitizensOrder! = mostVotingPower): [Delegate!]!

  projects(
    search: String
    category: [ProjectCategory!]
    orderBy: ProjectOrder! = alphabeticalAZ
    first: Int!
    after: String
    skip: Int
    seed: String
  ): ProjectsConnection!
  project(id: ID!): Project
  projectsAggregate: ProjectsAggregate!

  lists(
    search: String
    category: [ListCategory!]
    likedBy: String
    orderBy: ListOrder! = alphabeticalAZ
    first: Int!
    after: String
    skip: Int
    seed: String
  ): ListsConnection!
  list(id: ID!): List
  listsAggregate: ListsAggregate!
}

enum CitizensOrder {
  mostVotingPower
  shuffle
}

enum ProjectOrder {
  alphabeticalAZ
  alphabeticalZA
  shuffle
  byIncludedInBallots
}

enum ProjectCategory {
  COLLECTIVE_GOVERNANCE
  DEVELOPER_ECOSYSTEM
  END_USER_EXPERIENCE_AND_ADOPTION
  OP_STACK
}

enum ListCategory {
  COLLECTIVE_GOVERNANCE
  DEVELOPER_ECOSYSTEM
  END_USER_EXPERIENCE_AND_ADOPTION
  OP_STACK
  PAIRWISE
}

type ProjectsConnection {
  pageInfo: PageInfo!
  edges: [ProjectsEdge!]!
}

type ProjectsEdge {
  node: Project!
  cursor: String!
}

type Project {
  id: ID!
  applicant: Delegate!
  displayName: String!
  applicantType: String!
  websiteUrl: String!
  bio: String!
  contributionDescription: String!
  contributionLinks: [ContributionLink!]!
  impactCategory: [String!]!
  impactDescription: String!
  impactMetrics: [ImpactMetric!]!
  fundingSources: [FundingSource!]
  payoutAddress: Address!
  understoodKYCRequirements: Boolean!
  understoodFundClaimPeriod: Boolean!
  certifiedNotDesignatedOrSanctionedOrBlocked: Boolean!
  certifiedNotSponsoredByPoliticalFigureOrGovernmentEntity: Boolean!
  certifiedNotBarredFromParticipating: Boolean!

  includedInBallots: Int!
  lists: [List!]!
  profile: OptimistProfile
}

type OptimistProfile {
  id: ID!
  uid: String!
  name: String!
  profileImageUrl: String
  bannerImageUrl: String
  websiteUrl: String
  bio: String
}

type ProjectsAggregate {
  total: Int!
  collectiveGovernance: Int!
  developerEcosystem: Int!
  endUserExperienceAndAdoption: Int!
  opStack: Int!
}

type ContributionLink {
  type: String!
  url: String!
  description: String!
}

type ImpactMetric {
  description: String!
  number: String!
  url: String!
}

type FundingSource {
  type: String!
  currency: String!
  amount: Float!
  description: String!
}

enum ListOrder {
  alphabeticalAZ
  alphabeticalZA
  shuffle
  byLikes
}

type ListsConnection {
  pageInfo: PageInfo!
  edges: [ListsEdge!]!
}

type ListsEdge {
  node: List!
  cursor: String!
}

type List {
  id: ID!

  author: Address!

  listName: String!
  listDescription: String!
  impactEvaluationDescription: String!
  impactEvaluationLink: String!
  listContentCount: Int!
  listContentShort: [ListContent!]!
  listContent: [ListContent!]!
  categories: [String!]!

  likes: [String!]!
}

type ListContent {
  project: Project!
  OPAmount: Float!
}

type ListsAggregate {
  total: Int!
  collectiveGovernance: Int!
  developerEcosystem: Int!
  endUserExperienceAndAdoption: Int!
  opStack: Int!
  pairwise: Int!
}

type Mutation {
  createNewDelegateStatement(data: CreateNewDelegateStatementData!): Delegate!
}

input CreateNewDelegateStatementData {
  statement: ValueWithSignature!
  email: ValueWithSignature
}

input ValueWithSignature {
  # Address of the signer, this is used for logging and so we can implement
  # gnosis wallet multi-sig signature verification.
  signerAddress: String!
  value: String!
  signature: String!
  signatureType: SingatureType!
}

enum SingatureType {
  CONTRACT
  EOA
}
